#version 430 core

#define FLOAT_MAX 3.4028235e+38
#define FLOAT_MIN -3.4028235e+38
#define EPSILON 0.001

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D imgOutput;

struct Ray {
    vec3 Origin;
    vec3 Direction;
};

struct Sphere {
    vec4 Position;
    float Mat;
};

struct Cuboid {
	vec4 PositionLLC;
	vec4 U;
	vec4 V;
	float MaterialIndex;
	float Width;
	float Height;
};

struct Material {
    vec4 Color;
    float Roughness;
    float SpecularProbability;
    float RefractionRatio;
    float EmissiveStrenght;
    vec4 EmissiveColor;
};

struct HitInfo {
    float HitDistance;
    vec3 HitPosition;
    vec3 Normal;
    int ObjectIndex;
    int ObjectType;
};

Ray CalculateRayFromCamera(mat4 inverseProj, mat4 inverseView, vec3 cameraPos, vec2 ndc);
vec4 PerPixel(vec2 ndc);
HitInfo TraceRay(Ray ray);
HitInfo HandleHit(Ray ray, float hitDistance, int index, int objType);
HitInfo NoHit();
float HitSphere(Ray ray, Sphere sphere);
float HitCuboid(Ray ray, Cuboid cuboid);
float HitQuad(Ray ray, Cuboid cuboid);
vec3 GetNormal(Cuboid cuboid, vec3 surfacePosition);
uint GetPCGHash(inout uint seed);
float GetRandomFloat();
vec3 GetRandomVector(uint seed);

uniform int width;
uniform int height;
uniform int rendererFrame;
uniform int samplesPerPixel;
uniform int rayDepth;
uniform vec3 cameraPosition;
uniform mat4 inverseProjection;
uniform mat4 inverseView;
uniform vec3 BackgroundColor;

layout(std430, binding = 0) buffer SpheresBuffer {
    Sphere Spheres[];
};

layout(std430, binding = 1) buffer MaterialsBuffer {
    Material Materials[];
};

layout(std430, binding = 2) buffer CuboidsBuffer {
    Cuboid Cuboids[];
};

uint rndSeed;

void main() {
    ivec2 imageResultSize = imageSize(imgOutput);
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

    rndSeed = gl_GlobalInvocationID.x * 1973 + gl_GlobalInvocationID.y * 9277 + rendererFrame * 2699 | 1;

    vec4 value = vec4(0.0, 0.0, 0.0, 1.0);
    for(int i = 0; i < samplesPerPixel; i++) {
        // anti aliasing
        vec2 subPixelOffset = vec2(GetRandomFloat(), GetRandomFloat());
        vec2 ndc = (texelCoord + subPixelOffset) / imageResultSize * 2.0 - 1.0;

        value += PerPixel(ndc);
    }

    value /= samplesPerPixel;

    // accumulazione path tracing
    vec4 lastFrameColor = imageLoad(imgOutput, texelCoord).rgba;
    value = mix(lastFrameColor, value, 1.0 / (rendererFrame));

    imageStore(imgOutput, texelCoord, value);
}

vec4 PerPixel(vec2 ndc) {
    Ray ray = CalculateRayFromCamera(inverseProjection, inverseView, cameraPosition, ndc);

    Material material;
    float multiplier = 1.0;
    vec3 light = vec3(0.0);
    vec3 contribution = vec3(1.0);

    for(int i = 0; i < rayDepth; i++) {
        HitInfo hit = TraceRay(ray);

        if(hit.HitDistance < 0.0) {
            light += BackgroundColor * contribution;
            break;
        }

        if(hit.ObjectType == 0)
            material = Materials[int(Spheres[hit.ObjectIndex].Mat)];
        else if(hit.ObjectType == 1)
            material = Materials[int(Cuboids[hit.ObjectIndex].MaterialIndex)];

        // Sphere sphere = Spheres[hit.ObjectIndex];
        // Material material = Materials[int(sphere.Mat)];

        contribution *= vec3(material.Color);
        light += (vec3(material.EmissiveColor) * material.EmissiveStrenght);

        if(material.RefractionRatio > 1.0) {
            vec3 unitDirection = normalize(ray.Direction);
            float ni_over_nt = dot(unitDirection, hit.Normal) > 0 ? material.RefractionRatio : 1.0 / material.RefractionRatio;
            vec3 refractedDir = refract(unitDirection, hit.Normal, ni_over_nt);

            if(length(refractedDir) > 0.0) {
                vec3 newRayOrigin = hit.HitPosition + refractedDir * 0.0001;
                vec3 newRayDir = refractedDir;

                ray = Ray(newRayOrigin, newRayDir);
            } else {
                // total internal reflection
                vec3 reflectedDirection = reflect(unitDirection, hit.Normal);
                vec3 newRayOrigin = hit.HitPosition + reflectedDirection * 0.0001;
                vec3 newRayDir = refractedDir;

                ray = Ray(newRayOrigin, newRayDir);
            }

        } else {
            vec3 diffuse = normalize(hit.Normal + GetRandomVector(rndSeed));
            vec3 specular = reflect(ray.Direction, hit.Normal);

            vec3 newRayOrigin = hit.HitPosition + hit.Normal * 0.0001;
            vec3 newRayDir = normalize(mix(specular, diffuse, material.Roughness));

            ray = Ray(newRayOrigin, newRayDir);
        }
    }

    return vec4(light, 1.0);
}

HitInfo TraceRay(Ray ray) {
    float hitDistance = 100000.0;
    int index = -1;
    int objType = -1; // 0 Sphere, 1 Cuboid

    for(int i = 0; i < Spheres.length(); i++) {
        Sphere sphere = Spheres[i];

        float distance = HitSphere(ray, sphere);

        if(distance >= 0 && distance < hitDistance) {
            hitDistance = distance;
            index = i;
            objType = 0;
        }
    }

    for(int i = 0; i < Cuboids.length(); i++) {
        Cuboid cuboid = Cuboids[i];

        float distance = HitQuad(ray, cuboid);

        if(distance >= 0 && distance < hitDistance) {
            hitDistance = distance;
            index = i;
            objType = 1;
        }
    }

    if(index < 0) {
        HitInfo result = NoHit();
        return result;
    }

    HitInfo result = HandleHit(ray, hitDistance, index, objType);
    return result;
}

HitInfo HandleHit(Ray ray, float hitDistance, int index, int objType) {
    HitInfo hit;

    if(objType == 0) { // SPHERE
        vec3 spherePos = vec3(Spheres[index].Position);

        vec3 origin = ray.Origin - spherePos;
        vec3 closestPosition = spherePos;
        vec3 hitPosition = origin + ray.Direction * hitDistance;
        vec3 normal = normalize(hitPosition);
        hitPosition += closestPosition;

        hit = HitInfo(hitDistance, hitPosition, normal, index, 0);
    } else if(objType == 1) { // CUBOID
        vec3 origin = ray.Origin - vec3(Cuboids[index].PositionLLC);
        vec3 closestPosition = vec3(Cuboids[index].PositionLLC);
        vec3 hitPosition = origin + ray.Direction * hitDistance;
        vec3 normal = GetNormal(Cuboids[index], hitPosition);
        hitPosition += closestPosition;

        hit = HitInfo(hitDistance, hitPosition, normal, index, 1);
    }

    return hit;
}

HitInfo NoHit() {
    return HitInfo(-1.0, vec3(0.0), vec3(0.0), -1, -1);
}

float HitSphere(Ray ray, Sphere sphere) {
    vec3 spherePos = vec3(sphere.Position);
    float radius = sphere.Position.w;

    vec3 oc = ray.Origin - spherePos;
    float a = dot(ray.Direction, ray.Direction);
    float b = 2.0 * dot(oc, ray.Direction);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4.0 * a * c;

    if(discriminant < 0.0)
        return -1.0;

    float closestT = (-b - sqrt(discriminant)) / (2.0 * a);

    return closestT;
}

float HitCuboid(Ray ray, Cuboid cuboid) {
    // float t1 = FLOAT_MAX;
    // float t2 = FLOAT_MIN;

    // vec3 t0s = (cuboid.Min - ray.Origin) / ray.Direction;
    // vec3 t1s = (cuboid.Max - ray.Origin) / ray.Direction;

    // vec3 tSmaller = min(t0s, t1s);
    // vec3 tBigger = max(t0s, t1s);

    // t1 = max(t1, max(tSmaller.x, max(tSmaller.y, tSmaller.z)));
    // t2 = min(t1, min(tSmaller.x, min(tSmaller.y, tSmaller.z)));

    return 0.0;
}

float HitQuad(Ray ray, Cuboid cuboid) {
    vec3 normal = normalize(cross(vec3(cuboid.U), vec3(cuboid.V)));
    float d = dot(normal, vec3(cuboid.PositionLLC));
    vec3 w = normal / (dot(normal, normal) + 0.0001);

    float denom = dot(normal, ray.Direction);
    
    // no hit if the ray is parallel to the plane
    if (abs(denom) < 1e-8)
        return -1.0;

    float t = (d - dot(normal, ray.Origin)) / denom;
    if (t < 0.001 || t > uintBitsToFloat(0x7F800000))
        return -1.0;

    vec3 intersection = ray.Origin + (t * ray.Direction);
    vec3 planar_hitpt_vector = intersection - vec3(cuboid.PositionLLC);
    float alpha = dot(w, cross(planar_hitpt_vector, vec3(cuboid.V)));
    float beta = dot(w, cross(vec3(cuboid.U), planar_hitpt_vector));

    // is not interior
    if ((alpha < 0) || (cuboid.Width < alpha) || (beta < 0) || (cuboid.Height < beta))
        return -1;

    return t;
}

vec3 GetNormal(Cuboid cuboid, vec3 surfacePosition) {
    // vec3 halfSize = (cuboid.Max - cuboid.Min) * 0.5;
    // vec3 centerSurface = surfacePosition - (cuboid.Max + cuboid.Min) * 0.5;
    
    // vec3 normal = vec3(0.0);
    // normal += vec3(sign(centerSurface.x), 0.0, 0.0) * step(abs(abs(centerSurface.x) - halfSize.x), EPSILON);
    // normal += vec3(0.0, sign(centerSurface.y), 0.0) * step(abs(abs(centerSurface.y) - halfSize.y), EPSILON);
    // normal += vec3(0.0, 0.0, sign(centerSurface.z)) * step(abs(abs(centerSurface.z) - halfSize.z), EPSILON);
    return normalize(cross(vec3(cuboid.U), vec3(cuboid.V)));
}

Ray CalculateRayFromCamera(mat4 inverseProj, mat4 inverseView, vec3 cameraPos, vec2 ndc) {
    vec4 target = inverseProj * vec4(ndc, 1.0, 1.0);
    vec3 rayDirection = vec3(inverseView * vec4(normalize(vec3(target) / target.w), 0.0));

    return Ray(cameraPos, rayDirection);
}

uint GetPCGHash(inout uint seed) {
    seed = seed * 747796405u + 2891336453u;
    uint word = ((seed >> ((seed >> 28u) + 4u)) ^ seed) * 277803737u;
    return (word >> 22u) ^ word;
}
 
float GetRandomFloat() {
    return float(GetPCGHash(rndSeed)) / 4294967296.0;
}

vec3 GetRandomVector(uint seed) {
    vec3 seedVec = vec3(
        float(seed & 0xFF) / 255.0,
        float((seed >> 8) & 0xFF) / 255.0,
        float((seed >> 16) & 0xFF) / 255.0
    );

    return vec3(
        fract(sin(dot(seedVec, vec3(12.9898, 78.233, 45.543))) * 43758.5453) * 2.0 - 1.0,
        fract(sin(dot(seedVec, vec3(39.3465, 93.535, 23.987))) * 43758.5453) * 2.0 - 1.0,
        fract(sin(dot(seedVec, vec3(67.123, 12.789, 98.456))) * 43758.5453) * 2.0 - 1.0
    );
}